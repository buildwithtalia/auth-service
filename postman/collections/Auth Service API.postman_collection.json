{
  "info": {
    "_postman_id": "45b1e245-e286-48ce-8c1b-b0e3494df067",
    "name": "Auth Service API",
    "description": "# Auth Service API\n\nA secure, production-ready authentication system built with a microservices architecture. The system is split into two specialized services working together to provide comprehensive authentication and session management capabilities.\n\n## üèóÔ∏è Architecture Overview\n\nThis API consists of two independent microservices:\n\n- **Login Service** (Port 3001): Handles user registration, authentication, and token generation\n- **Logout Service** (Port 3002): Manages token invalidation, session termination, and token blacklisting\n\n## üöÄ Getting Started\n\n### Base URLs\n\nThe services run on localhost by default:\n\n```\nLogin Service:  http://localhost:3001\nLogout Service: http://localhost:3002\n```\n\n### Environment Variables\n\nThis collection uses the following variables:\n\n| Variable | Default Value | Description |\n|----------|---------------|-------------|\n| `baseUrl` | `http://localhost` | Base URL for both services |\n| `loginServicePort` | `3001` | Port for Login Service |\n| `logoutServicePort` | `3002` | Port for Logout Service |\n| `accessToken` | (empty) | JWT access token (auto-populated after login) |\n| `refreshToken` | (empty) | JWT refresh token (auto-populated after login) |\n| `userId` | (empty) | User ID (auto-populated after registration) |\n\n## üîê Authentication\n\nThis API uses **Bearer Token Authentication** with JWT (JSON Web Tokens).\n\n### Token Types\n\n1. **Access Token**: Short-lived token (24 hours) used for authenticating API requests\n2. **Refresh Token**: Long-lived token (7 days) stored as HTTP-only cookie, used to obtain new access tokens\n\n### Using Authentication\n\nInclude the access token in the Authorization header for protected endpoints:\n\n```\nAuthorization: Bearer {{accessToken}}\n```\n\nThe collection automatically manages tokens through test scripts:\n- Login/Register requests save the `accessToken` to collection variables\n- Protected requests use `{{accessToken}}` variable\n- Refresh endpoint updates the token automatically\n\n## üìã Common Workflows\n\n### 1. New User Registration\n\n```\nPOST /api/auth/register\n```\n\nRegister a new user account. The request automatically generates random credentials that meet password requirements.\n\n### 2. User Login\n\n```\nPOST /api/auth/login\n```\n\nAuthenticate with email and password. Returns an access token and sets a refresh token cookie.\n\n### 3. Access Protected Resources\n\n```\nGET /api/auth/me\nAuthorization: Bearer {{accessToken}}\n```\n\nUse the access token to access protected endpoints like user profile.\n\n### 4. Token Refresh\n\n```\nPOST /api/auth/refresh\n```\n\nWhen the access token expires, use this endpoint to get a new one using the refresh token cookie.\n\n### 5. Logout\n\n```\nPOST /api/logout\nAuthorization: Bearer {{accessToken}}\n```\n\nInvalidate the current session by blacklisting the access token.\n\n## üìä Response Format\n\nAll endpoints return JSON responses with consistent structure:\n\n### Success Response\n```json\n{\n  \"success\": true,\n  \"data\": { ... },\n  \"message\": \"Operation successful\"\n}\n```\n\n### Error Response\n```json\n{\n  \"success\": false,\n  \"error\": \"Error message\",\n  \"code\": \"ERROR_CODE\"\n}\n```\n\n## üîí Security Features\n\n- **Password Requirements**: 8-128 characters with at least one lowercase, uppercase, number, and special character\n- **JWT Tokens**: Cryptographically signed tokens with expiration\n- **Token Blacklisting**: Logout immediately invalidates tokens\n- **HTTP-Only Cookies**: Refresh tokens stored securely\n- **Session Management**: Track and manage active sessions across devices\n\n## ‚ö†Ô∏è Common Error Codes\n\n| Status Code | Description |\n|-------------|-------------|\n| `200` | Success |\n| `201` | Resource created successfully |\n| `400` | Bad request - Invalid input data |\n| `401` | Unauthorized - Invalid or missing token |\n| `403` | Forbidden - Token blacklisted or insufficient permissions |\n| `404` | Not found - Resource doesn't exist |\n| `409` | Conflict - Resource already exists (e.g., email in use) |\n| `500` | Internal server error |\n\n## üß™ Testing\n\nThis collection includes comprehensive test scripts that automatically:\n- Validate response status codes\n- Check response structure and data types\n- Verify JWT token format and expiration\n- Extract and save tokens for subsequent requests\n- Validate business logic rules\n\nRun the entire collection using the Collection Runner to test all endpoints in sequence.\n\n## üìù Additional Notes\n\n- All timestamps are in ISO 8601 format\n- Tokens are automatically managed by collection scripts\n- The Logout Service maintains a blacklist of invalidated tokens\n- Expired tokens are automatically cleaned up by the maintenance endpoint",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Login Service",
      "item": [
        {
          "name": "Health Check",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 500ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(500);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains status field', function() {",
                  "    pm.expect(jsonData).to.have.property('status');",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Status field is a string', function() {",
                  "    pm.expect(jsonData.status).to.be.a('string');",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Service status indicates healthy state', function() {",
                  "    const validStatuses = ['ok', 'healthy', 'up', 'running'];",
                  "    pm.expect(validStatuses).to.include(jsonData.status.toLowerCase());",
                  "});",
                  "",
                  "pm.test('Uptime is present and valid (if exists)', function() {",
                  "    if (jsonData.uptime !== undefined) {",
                  "        pm.expect(jsonData.uptime).to.be.a('number');",
                  "        pm.expect(jsonData.uptime).to.be.at.least(0);",
                  "    }",
                  "});",
                  "",
                  "pm.test('Timestamp is present and valid (if exists)', function() {",
                  "    if (jsonData.timestamp !== undefined) {",
                  "        pm.expect(jsonData.timestamp).to.be.a('string');",
                  "        pm.expect(new Date(jsonData.timestamp).toString()).to.not.equal('Invalid Date');",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "0bcf83f5-4643-4307-9c4d-7471bd53b417",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}:{{loginServicePort}}/health",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{loginServicePort}}",
              "path": [
                "health"
              ]
            },
            "description": "Check if the Login Service is healthy and running"
          },
          "response": []
        },
        {
          "name": "Service Info",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 500ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(500);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains service name', function() {",
                  "    pm.expect(jsonData).to.have.property('service');",
                  "});",
                  "",
                  "pm.test('Response contains version information', function() {",
                  "    pm.expect(jsonData).to.have.property('version');",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Service name is a string', function() {",
                  "    pm.expect(jsonData.service).to.be.a('string');",
                  "});",
                  "",
                  "pm.test('Version is a string', function() {",
                  "    pm.expect(jsonData.version).to.be.a('string');",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Service name indicates Login Service', function() {",
                  "    pm.expect(jsonData.service.toLowerCase()).to.include('login');",
                  "});",
                  "",
                  "pm.test('Version follows semantic versioning pattern', function() {",
                  "    const semverPattern = /^\\d+\\.\\d+\\.\\d+/;",
                  "    pm.expect(jsonData.version).to.match(semverPattern);",
                  "});",
                  "",
                  "pm.test('Endpoints array is present (if exists)', function() {",
                  "    if (jsonData.endpoints !== undefined) {",
                  "        pm.expect(jsonData.endpoints).to.be.an('array');",
                  "        pm.expect(jsonData.endpoints.length).to.be.at.least(1);",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "cd4b930d-a9aa-481d-bbb3-9540917b6f3b",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}:{{loginServicePort}}/",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{loginServicePort}}",
              "path": [
                ""
              ]
            },
            "description": "Get information about the Login Service and available endpoints"
          },
          "response": []
        },
        {
          "name": "Register User",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "ea8f6680-04a1-44c7-aa71-9c6222050085",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 201 Created or 200 OK', function() {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "pm.test('Status code is not 400 Bad Request (valid input)', function() {",
                  "    pm.response.to.not.have.status(400);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 2000ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains success indicator', function() {",
                  "    pm.expect(jsonData).to.have.property('success');",
                  "    pm.expect(jsonData.success).to.be.true;",
                  "});",
                  "",
                  "pm.test('Response contains data object with user', function() {",
                  "    pm.expect(jsonData).to.have.property('data');",
                  "    pm.expect(jsonData.data).to.have.property('user');",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('User ID is valid', function() {",
                  "    pm.expect(jsonData.data.user).to.have.property('id');",
                  "    pm.expect(jsonData.data.user.id).to.be.a('string');",
                  "    pm.expect(jsonData.data.user.id).to.have.lengthOf.at.least(1);",
                  "});",
                  "",
                  "pm.test('Email in response is valid', function() {",
                  "    pm.expect(jsonData.data.user).to.have.property('email');",
                  "    pm.expect(jsonData.data.user.email).to.be.a('string');",
                  "    pm.expect(jsonData.data.user.email).to.include('@');",
                  "});",
                  "",
                  "pm.test('Created timestamp is present', function() {",
                  "    pm.expect(jsonData.data.user).to.have.property('createdAt');",
                  "    pm.expect(jsonData.data.user.createdAt).to.be.a('string');",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Password is not returned in response', function() {",
                  "    pm.expect(jsonData).to.not.have.property('password');",
                  "    pm.expect(jsonData.data.user).to.not.have.property('password');",
                  "});",
                  "",
                  "pm.test('Access token is provided on successful registration', function() {",
                  "    pm.expect(jsonData.data).to.have.property('accessToken');",
                  "    pm.expect(jsonData.data.accessToken).to.be.a('string');",
                  "    // JWT format validation: header.payload.signature",
                  "    const jwtPattern = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$/;",
                  "    pm.expect(jsonData.data.accessToken).to.match(jwtPattern);",
                  "});",
                  "",
                  "// Variable Extraction",
                  "pm.test('Save access token for subsequent requests', function() {",
                  "    pm.collectionVariables.set('accessToken', jsonData.data.accessToken);",
                  "    pm.expect(pm.collectionVariables.get('accessToken')).to.equal(jsonData.data.accessToken);",
                  "});",
                  "",
                  "pm.test('Save user ID for subsequent requests', function() {",
                  "    pm.collectionVariables.set('userId', jsonData.data.user.id);",
                  "    pm.expect(pm.collectionVariables.get('userId')).to.equal(jsonData.data.user.id);",
                  "});",
                  "",
                  "pm.test('Save registered email for subsequent requests', function() {",
                  "    pm.collectionVariables.set('registeredEmail', jsonData.data.user.email);",
                  "    pm.expect(pm.collectionVariables.get('registeredEmail')).to.equal(jsonData.data.user.email);",
                  "});"
                ],
                "type": "text/javascript",
                "packages": {},
                "requests": {}
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "477923ba-a39a-4326-bd56-b85c0b179d73",
                "exec": [
                  "// Generate random email address",
                  "const randomString = Math.random().toString(36).substring(2, 10);",
                  "const randomEmail = `user_${randomString}@example.com`;",
                  "",
                  "// Generate random password meeting requirements:",
                  "// 8-128 characters with at least one lowercase, one uppercase, one number, and one special character",
                  "function generatePassword() {",
                  "    const lowercase = 'abcdefghijklmnopqrstuvwxyz';",
                  "    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';",
                  "    const numbers = '0123456789';",
                  "    const special = '!@#$%^&*()_+-=[]{}|;:,.<>?';",
                  "    const allChars = lowercase + uppercase + numbers + special;",
                  "    ",
                  "    // Ensure at least one of each required character type",
                  "    let password = '';",
                  "    password += lowercase.charAt(Math.floor(Math.random() * lowercase.length));",
                  "    password += uppercase.charAt(Math.floor(Math.random() * uppercase.length));",
                  "    password += numbers.charAt(Math.floor(Math.random() * numbers.length));",
                  "    password += special.charAt(Math.floor(Math.random() * special.length));",
                  "    ",
                  "    // Fill remaining characters (random length between 8-16 for practicality)",
                  "    const remainingLength = Math.floor(Math.random() * 9) + 4; // 4-12 more chars (total 8-16)",
                  "    for (let i = 0; i < remainingLength; i++) {",
                  "        password += allChars.charAt(Math.floor(Math.random() * allChars.length));",
                  "    }",
                  "    ",
                  "    // Shuffle the password to randomize character positions",
                  "    password = password.split('').sort(() => Math.random() - 0.5).join('');",
                  "    ",
                  "    return password;",
                  "}",
                  "",
                  "const randomPassword = generatePassword();",
                  "",
                  "// Set as local variables for use in request body",
                  "pm.variables.set('randomEmail', randomEmail);",
                  "pm.variables.set('randomPassword', randomPassword);",
                  "",
                  "// Save to collection variables for use in Login request",
                  "pm.collectionVariables.set('randomEmail', randomEmail);",
                  "pm.collectionVariables.set('randomPassword', randomPassword);",
                  "",
                  "console.log('Generated email:', randomEmail);",
                  "console.log('Generated password:', randomPassword);"
                ],
                "type": "text/javascript",
                "packages": {},
                "requests": {}
              }
            }
          ],
          "id": "ecff5370-de8a-4aff-a9f5-bf30ec86c051",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\"email\":\"{{randomEmail}}\",\"password\":\"{{randomPassword}}\"}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}:{{loginServicePort}}/api/auth/register",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{loginServicePort}}",
              "path": [
                "api",
                "auth",
                "register"
              ]
            },
            "description": "Register a new user. Password must be 8-128 characters with at least one lowercase, one uppercase, one number, and one special character."
          },
          "response": []
        },
        {
          "name": "Login User",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "3ce62324-435a-4f51-87ff-18e7ac653f2f",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK or expected error', function() {",
                  "    // Accept 200 for success, 429 for rate limit, 401 for invalid credentials",
                  "    const acceptableStatuses = [200, 401, 429];",
                  "    pm.expect(acceptableStatuses).to.include(pm.response.code);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 1000ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(1000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Handle successful login",
                  "if (pm.response.code === 200) {",
                  "    // Required Fields Tests",
                  "    pm.test('Response contains data object', function() {",
                  "        pm.expect(jsonData).to.have.property('data');",
                  "    });",
                  "",
                  "    pm.test('Response contains accessToken in data', function() {",
                  "        pm.expect(jsonData.data).to.have.property('accessToken');",
                  "    });",
                  "",
                  "    pm.test('Response contains user object in data', function() {",
                  "        pm.expect(jsonData.data).to.have.property('user');",
                  "    });",
                  "",
                  "    // Data Type Tests",
                  "    pm.test('Access token is a string', function() {",
                  "        pm.expect(jsonData.data.accessToken).to.be.a('string');",
                  "    });",
                  "",
                  "    pm.test('Access token is not empty', function() {",
                  "        pm.expect(jsonData.data.accessToken).to.not.be.empty;",
                  "    });",
                  "",
                  "    pm.test('User ID is present', function() {",
                  "        pm.expect(jsonData.data.user).to.have.property('id');",
                  "        pm.expect(jsonData.data.user.id).to.be.a('string');",
                  "    });",
                  "",
                  "    pm.test('User email is present', function() {",
                  "        pm.expect(jsonData.data.user).to.have.property('email');",
                  "        pm.expect(jsonData.data.user.email).to.be.a('string');",
                  "    });",
                  "",
                  "    // Save token, userId, and email to collection variables",
                  "    if (jsonData.data && jsonData.data.accessToken) {",
                  "        pm.collectionVariables.set('accessToken', jsonData.data.accessToken);",
                  "        console.log('Access token saved to collection variables');",
                  "    }",
                  "",
                  "    if (jsonData.data && jsonData.data.user) {",
                  "        if (jsonData.data.user.id) {",
                  "            pm.collectionVariables.set('userId', jsonData.data.user.id);",
                  "            console.log('User ID saved to collection variables:', jsonData.data.user.id);",
                  "        }",
                  "        if (jsonData.data.user.email) {",
                  "            pm.collectionVariables.set('userEmail', jsonData.data.user.email);",
                  "            console.log('User email saved to collection variables:', jsonData.data.user.email);",
                  "        }",
                  "    }",
                  "",
                  "    pm.test('Access token was saved to collection variables', function() {",
                  "        pm.expect(pm.collectionVariables.get('accessToken')).to.equal(jsonData.data.accessToken);",
                  "    });",
                  "",
                  "    pm.test('User ID was saved to collection variables', function() {",
                  "        pm.expect(pm.collectionVariables.get('userId')).to.equal(jsonData.data.user.id);",
                  "    });",
                  "",
                  "    pm.test('User email was saved to collection variables', function() {",
                  "        pm.expect(pm.collectionVariables.get('userEmail')).to.equal(jsonData.data.user.email);",
                  "    });",
                  "} else {",
                  "    // Handle error responses",
                  "    pm.test('Error response contains message', function() {",
                  "        pm.expect(jsonData).to.have.property('message');",
                  "    });",
                  "",
                  "    if (pm.response.code === 429) {",
                  "        pm.test('Rate limit error is properly formatted', function() {",
                  "            pm.expect(jsonData.error).to.equal('RATE_LIMIT_EXCEEDED');",
                  "        });",
                  "        console.log('Rate limit exceeded. Please wait before trying again.');",
                  "    } else if (pm.response.code === 401) {",
                  "        pm.test('Authentication error is properly formatted', function() {",
                  "            pm.expect(jsonData.success).to.be.false;",
                  "        });",
                  "        console.log('Authentication failed. Check credentials.');",
                  "    }",
                  "}"
                ],
                "type": "text/javascript",
                "packages": {},
                "requests": {}
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "061e934b-1e22-4d32-95ae-56e545a1081f",
                "exec": [
                  "// Check if we have saved credentials from registration",
                  "const savedEmail = pm.collectionVariables.get('randomEmail');",
                  "const savedPassword = pm.collectionVariables.get('randomPassword');",
                  "",
                  "if (savedEmail && savedPassword) {",
                  "    // Use the saved credentials from registration",
                  "    pm.variables.set('randomEmail', savedEmail);",
                  "    pm.variables.set('randomPassword', savedPassword);",
                  "    console.log('Using saved credentials from registration');",
                  "    console.log('Email:', savedEmail);",
                  "} else {",
                  "    // Generate new credentials and save them for registration",
                  "    const randomEmail = `user${Date.now()}@example.com`;",
                  "    ",
                  "    function generatePassword() {",
                  "        const lowercase = 'abcdefghijklmnopqrstuvwxyz';",
                  "        const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';",
                  "        const numbers = '0123456789';",
                  "        const special = '!@#$%^&*()_+-=[]{}|;:,.<>?';",
                  "        ",
                  "        let password = '';",
                  "        password += lowercase[Math.floor(Math.random() * lowercase.length)];",
                  "        password += uppercase[Math.floor(Math.random() * uppercase.length)];",
                  "        password += numbers[Math.floor(Math.random() * numbers.length)];",
                  "        password += special[Math.floor(Math.random() * special.length)];",
                  "        ",
                  "        const allChars = lowercase + uppercase + numbers + special;",
                  "        for (let i = password.length; i < 12; i++) {",
                  "            password += allChars[Math.floor(Math.random() * allChars.length)];",
                  "        }",
                  "        ",
                  "        password = password.split('').sort(() => Math.random() - 0.5).join('');",
                  "        return password;",
                  "    }",
                  "    ",
                  "    const randomPassword = generatePassword();",
                  "    ",
                  "    // Save to collection variables for future use",
                  "    pm.collectionVariables.set('randomEmail', randomEmail);",
                  "    pm.collectionVariables.set('randomPassword', randomPassword);",
                  "    ",
                  "    // Set as local variables for use in request body",
                  "    pm.variables.set('randomEmail', randomEmail);",
                  "    pm.variables.set('randomPassword', randomPassword);",
                  "    ",
                  "    console.log('Generated new credentials (you may need to register first)');",
                  "    console.log('Email:', randomEmail);",
                  "    console.log('Password:', randomPassword);",
                  "}"
                ],
                "type": "text/javascript",
                "packages": {},
                "requests": {}
              }
            }
          ],
          "id": "f2fd11c4-bd4c-4885-8535-e4a1ff36e670",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\"email\":\"{{randomEmail}}\",\"password\":\"{{randomPassword}}\"}"
            },
            "url": {
              "raw": "{{baseUrl}}:{{loginServicePort}}/api/auth/login",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{loginServicePort}}",
              "path": [
                "api",
                "auth",
                "login"
              ]
            },
            "description": "Login user and receive access token and refresh token (stored as HTTP-only cookie)"
          },
          "response": []
        },
        {
          "name": "Get User Profile",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('Request is not unauthorized (401)', function() {",
                  "    pm.response.to.not.have.status(401);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 1000ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(1000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains user object or user data', function() {",
                  "    const hasUser = jsonData.hasOwnProperty('user') || jsonData.hasOwnProperty('email');",
                  "    pm.expect(hasUser).to.be.true;",
                  "});",
                  "",
                  "pm.test('User has email field', function() {",
                  "    const email = jsonData.user ? jsonData.user.email : jsonData.email;",
                  "    pm.expect(email).to.exist;",
                  "});",
                  "",
                  "pm.test('User has ID field', function() {",
                  "    const id = jsonData.user ? jsonData.user.id : jsonData.id;",
                  "    pm.expect(id).to.exist;",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Email is a valid string', function() {",
                  "    const email = jsonData.user ? jsonData.user.email : jsonData.email;",
                  "    pm.expect(email).to.be.a('string');",
                  "});",
                  "",
                  "pm.test('User ID is a valid string', function() {",
                  "    const id = jsonData.user ? jsonData.user.id : jsonData.id;",
                  "    pm.expect(id).to.be.a('string');",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Email has valid format', function() {",
                  "    const email = jsonData.user ? jsonData.user.email : jsonData.email;",
                  "    const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;",
                  "    pm.expect(email).to.match(emailPattern);",
                  "});",
                  "",
                  "pm.test('Password is not exposed in response', function() {",
                  "    pm.expect(jsonData.password).to.be.undefined;",
                  "    if (jsonData.user) {",
                  "        pm.expect(jsonData.user.password).to.be.undefined;",
                  "    }",
                  "});",
                  "",
                  "pm.test('Sensitive data is not exposed', function() {",
                  "    pm.expect(jsonData.passwordHash).to.be.undefined;",
                  "    pm.expect(jsonData.salt).to.be.undefined;",
                  "    if (jsonData.user) {",
                  "        pm.expect(jsonData.user.passwordHash).to.be.undefined;",
                  "        pm.expect(jsonData.user.salt).to.be.undefined;",
                  "    }",
                  "});",
                  "",
                  "pm.test('Created date is valid (if present)', function() {",
                  "    const createdAt = jsonData.user ? jsonData.user.createdAt : jsonData.createdAt;",
                  "    if (createdAt) {",
                  "        pm.expect(new Date(createdAt).toString()).to.not.equal('Invalid Date');",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "3ef63698-ffaf-4932-a80b-6b1bebc44ccb",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{accessToken}}"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}:{{loginServicePort}}/api/auth/me",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{loginServicePort}}",
              "path": [
                "api",
                "auth",
                "me"
              ]
            },
            "description": "Get the current user's profile information. Requires valid access token."
          },
          "response": []
        },
        {
          "name": "Refresh Access Token",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 1500ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(1500);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains new access token', function() {",
                  "    pm.expect(jsonData).to.have.property('accessToken');",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Access token is a string', function() {",
                  "    pm.expect(jsonData.accessToken).to.be.a('string');",
                  "});",
                  "",
                  "// Business Logic Tests - JWT Validation",
                  "pm.test('New access token is valid JWT format', function() {",
                  "    const jwtPattern = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$/;",
                  "    pm.expect(jsonData.accessToken).to.match(jwtPattern);",
                  "});",
                  "",
                  "pm.test('New JWT has valid structure with 3 parts', function() {",
                  "    const parts = jsonData.accessToken.split('.');",
                  "    pm.expect(parts).to.have.lengthOf(3);",
                  "});",
                  "",
                  "pm.test('New JWT payload is decodable', function() {",
                  "    const parts = jsonData.accessToken.split('.');",
                  "    try {",
                  "        const payload = JSON.parse(atob(parts[1]));",
                  "        pm.expect(payload).to.be.an('object');",
                  "    } catch (e) {",
                  "        pm.expect.fail('JWT payload is not valid base64 JSON');",
                  "    }",
                  "});",
                  "",
                  "pm.test('New JWT contains expiration claim', function() {",
                  "    const parts = jsonData.accessToken.split('.');",
                  "    const payload = JSON.parse(atob(parts[1]));",
                  "    pm.expect(payload).to.have.property('exp');",
                  "    pm.expect(payload.exp).to.be.a('number');",
                  "});",
                  "",
                  "pm.test('New JWT expiration is in the future', function() {",
                  "    const parts = jsonData.accessToken.split('.');",
                  "    const payload = JSON.parse(atob(parts[1]));",
                  "    const now = Math.floor(Date.now() / 1000);",
                  "    pm.expect(payload.exp).to.be.above(now);",
                  "});",
                  "",
                  "pm.test('New token is different from old token (token rotation)', function() {",
                  "    const oldToken = pm.collectionVariables.get('accessToken');",
                  "    if (oldToken && oldToken !== '') {",
                  "        pm.expect(jsonData.accessToken).to.not.equal(oldToken);",
                  "    }",
                  "});",
                  "",
                  "// Variable Extraction - Update access token",
                  "pm.test('Update access token in collection variables', function() {",
                  "    pm.collectionVariables.set('accessToken', jsonData.accessToken);",
                  "    pm.expect(pm.collectionVariables.get('accessToken')).to.equal(jsonData.accessToken);",
                  "});",
                  "",
                  "pm.test('Update refresh token if rotated', function() {",
                  "    if (jsonData.refreshToken) {",
                  "        pm.collectionVariables.set('refreshToken', jsonData.refreshToken);",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "867fb6f8-bbb1-4e7d-bea0-bef73b4a6ded",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}:{{loginServicePort}}/api/auth/refresh",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{loginServicePort}}",
              "path": [
                "api",
                "auth",
                "refresh"
              ]
            },
            "description": "Refresh the access token using the refresh token stored in HTTP-only cookie"
          },
          "response": []
        }
      ],
      "id": "6251eb04-820c-4d39-aab0-eda51989d3a5",
      "description": "Handles user authentication and token generation (Port 3001)"
    },
    {
      "name": "Logout Service",
      "item": [
        {
          "name": "Health Check",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 500ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(500);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains status field', function() {",
                  "    pm.expect(jsonData).to.have.property('status');",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Status field is a string', function() {",
                  "    pm.expect(jsonData.status).to.be.a('string');",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Service status indicates healthy state', function() {",
                  "    const validStatuses = ['ok', 'healthy', 'up', 'running'];",
                  "    pm.expect(validStatuses).to.include(jsonData.status.toLowerCase());",
                  "});",
                  "",
                  "pm.test('Uptime is present and valid (if exists)', function() {",
                  "    if (jsonData.uptime !== undefined) {",
                  "        pm.expect(jsonData.uptime).to.be.a('number');",
                  "        pm.expect(jsonData.uptime).to.be.at.least(0);",
                  "    }",
                  "});",
                  "",
                  "pm.test('Timestamp is present and valid (if exists)', function() {",
                  "    if (jsonData.timestamp !== undefined) {",
                  "        pm.expect(jsonData.timestamp).to.be.a('string');",
                  "        pm.expect(new Date(jsonData.timestamp).toString()).to.not.equal('Invalid Date');",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "01a323bc-14d3-4d0f-aefc-ad44d3e21724",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/health",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                "health"
              ]
            },
            "description": "Check if the Logout Service is healthy and running"
          },
          "response": []
        },
        {
          "name": "Service Info",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 500ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(500);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains service name', function() {",
                  "    pm.expect(jsonData).to.have.property('service');",
                  "});",
                  "",
                  "pm.test('Response contains version information', function() {",
                  "    pm.expect(jsonData).to.have.property('version');",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Service name is a string', function() {",
                  "    pm.expect(jsonData.service).to.be.a('string');",
                  "});",
                  "",
                  "pm.test('Version is a string', function() {",
                  "    pm.expect(jsonData.version).to.be.a('string');",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Service name indicates Logout Service', function() {",
                  "    pm.expect(jsonData.service.toLowerCase()).to.include('logout');",
                  "});",
                  "",
                  "pm.test('Version follows semantic versioning pattern', function() {",
                  "    const semverPattern = /^\\\\d+\\\\.\\\\d+\\\\.\\\\d+/;",
                  "    pm.expect(jsonData.version).to.match(semverPattern);",
                  "});",
                  "",
                  "pm.test('Endpoints array is present (if exists)', function() {",
                  "    if (jsonData.endpoints !== undefined) {",
                  "        pm.expect(jsonData.endpoints).to.be.an('array');",
                  "        pm.expect(jsonData.endpoints.length).to.be.at.least(1);",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "67ae2c7b-045f-4824-a42a-85f7def35615",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                ""
              ]
            },
            "description": "Get information about the Logout Service and available endpoints"
          },
          "response": []
        },
        {
          "name": "Logout User",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "f7d4a426-db5d-4312-8dbd-548596de5c26",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('Request requires authentication (not 401 when token provided)', function() {",
                  "    pm.response.to.not.have.status(401);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 1000ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(1000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains success indicator or message', function() {",
                  "    const hasIndicator = jsonData.hasOwnProperty('success') || jsonData.hasOwnProperty('message');",
                  "    pm.expect(hasIndicator).to.be.true;",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Success field is boolean (if present)', function() {",
                  "    if (jsonData.success !== undefined) {",
                  "        pm.expect(jsonData.success).to.be.a('boolean');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Message field is string (if present)', function() {",
                  "    if (jsonData.message !== undefined) {",
                  "        pm.expect(jsonData.message).to.be.a('string');",
                  "    }",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Logout was successful', function() {",
                  "    if (jsonData.success !== undefined) {",
                  "        pm.expect(jsonData.success).to.be.true;",
                  "    } else if (jsonData.message) {",
                  "        pm.expect(jsonData.message.toLowerCase()).to.include('success');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Token should be invalidated after logout', function() {",
                  "    // Note: The token used for this request should now be blacklisted",
                  "    // Subsequent requests with this token should fail",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "// Variable Cleanup - Clear tokens after logout",
                  "pm.test('Clear access token after successful logout', function() {",
                  "    if (pm.response.code === 200) {",
                  "        pm.collectionVariables.set('accessToken', '');",
                  "    }",
                  "});"
                ],
                "type": "text/javascript",
                "packages": {},
                "requests": {}
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "9db141bf-156a-4b1d-aed2-e72868350565",
                "exec": [
                  "// Validate that required variables are set before logout",
                  "const accessToken = pm.collectionVariables.get('accessToken');",
                  "const userId = pm.collectionVariables.get('userId');",
                  "const userEmail = pm.collectionVariables.get('userEmail');",
                  "",
                  "if (!accessToken || accessToken === '') {",
                  "    console.warn('Warning: accessToken is not set. You may need to login first.');",
                  "    console.log('Run the \"Login User\" request to obtain an access token.');",
                  "} else {",
                  "    console.log('Access token found:', accessToken.substring(0, 20) + '...');",
                  "}",
                  "",
                  "if (!userId || userId === '') {",
                  "    console.warn('Warning: userId is not set. This was expected to be set by Login User request.');",
                  "} else {",
                  "    console.log('User ID found:', userId);",
                  "}",
                  "",
                  "if (!userEmail || userEmail === '') {",
                  "    console.warn('Warning: userEmail is not set. This was expected to be set by Login User request.');",
                  "} else {",
                  "    console.log('User email found:', userEmail);",
                  "}",
                  "",
                  "// Log the logout attempt",
                  "console.log('Attempting to logout user...');"
                ],
                "type": "text/javascript",
                "packages": {},
                "requests": {}
              }
            }
          ],
          "id": "b5a869ff-df5c-4cd7-87c2-3ff28b73c780",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{accessToken}}"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/api/logout",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                "api",
                "logout"
              ]
            },
            "description": "Logout user from current session. Blacklists the access token and removes refresh token."
          },
          "response": [
            {
              "id": "a2125809-f711-4e52-a3de-02af25a36844",
              "name": "Successful Logout",
              "originalRequest": {
                "method": "POST",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}:{{logoutServicePort}}/api/logout",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "port": "{{logoutServicePort}}",
                  "path": [
                    "api",
                    "logout"
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n  \"success\": true,\n  \"message\": \"Logout successful\",\n  \"data\": {\n    \"tokenBlacklisted\": true,\n    \"logoutTime\": \"2024-01-22T20:00:00.000Z\"\n  }\n}"
            }
          ]
        },
        {
          "name": "Logout from All Devices",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('Request requires authentication (not 401 when token provided)', function() {",
                  "    pm.response.to.not.have.status(401);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 2000ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains success indicator or message', function() {",
                  "    const hasIndicator = jsonData.hasOwnProperty('success') || jsonData.hasOwnProperty('message');",
                  "    pm.expect(hasIndicator).to.be.true;",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Success field is boolean (if present)', function() {",
                  "    if (jsonData.success !== undefined) {",
                  "        pm.expect(jsonData.success).to.be.a('boolean');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Message field is string (if present)', function() {",
                  "    if (jsonData.message !== undefined) {",
                  "        pm.expect(jsonData.message).to.be.a('string');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Sessions count is number (if present)', function() {",
                  "    if (jsonData.sessionsInvalidated !== undefined) {",
                  "        pm.expect(jsonData.sessionsInvalidated).to.be.a('number');",
                  "        pm.expect(jsonData.sessionsInvalidated).to.be.at.least(0);",
                  "    }",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Logout from all devices was successful', function() {",
                  "    if (jsonData.success !== undefined) {",
                  "        pm.expect(jsonData.success).to.be.true;",
                  "    } else if (jsonData.message) {",
                  "        pm.expect(jsonData.message.toLowerCase()).to.include('success');",
                  "    }",
                  "});",
                  "",
                  "pm.test('All sessions should be invalidated', function() {",
                  "    // After this operation, all refresh tokens for the user should be invalid",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "// Variable Cleanup - Clear all tokens after logout-all",
                  "pm.test('Clear all tokens after successful logout-all', function() {",
                  "    if (pm.response.code === 200) {",
                  "        pm.collectionVariables.set('accessToken', '');",
                  "        pm.collectionVariables.set('refreshToken', '');",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "8dcaeb49-aade-40e4-8413-ac4744f9246b",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{accessToken}}"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/api/logout-all",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                "api",
                "logout-all"
              ]
            },
            "description": "Logout user from all devices by invalidating all refresh tokens"
          },
          "response": []
        },
        {
          "name": "Invalidate Specific Token",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK or 400 for invalid input', function() {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 400]);",
                  "});",
                  "",
                  "pm.test('Request requires authentication (not 401 when token provided)', function() {",
                  "    pm.response.to.not.have.status(401);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 1000ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(1000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains success indicator or error message', function() {",
                  "    const hasIndicator = jsonData.hasOwnProperty('success') || jsonData.hasOwnProperty('message') || jsonData.hasOwnProperty('error');",
                  "    pm.expect(hasIndicator).to.be.true;",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Success field is boolean (if present)', function() {",
                  "    if (jsonData.success !== undefined) {",
                  "        pm.expect(jsonData.success).to.be.a('boolean');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Message field is string (if present)', function() {",
                  "    if (jsonData.message !== undefined) {",
                  "        pm.expect(jsonData.message).to.be.a('string');",
                  "    }",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Token type validation (access or refresh)', function() {",
                  "    const requestBody = JSON.parse(pm.request.body.raw);",
                  "    if (requestBody.tokenType) {",
                  "        const validTypes = ['access', 'refresh'];",
                  "        pm.expect(validTypes).to.include(requestBody.tokenType);",
                  "    }",
                  "});",
                  "",
                  "pm.test('Token format validation in request', function() {",
                  "    const requestBody = JSON.parse(pm.request.body.raw);",
                  "    if (requestBody.token && requestBody.token !== 'jwt_token_to_invalidate') {",
                  "        // If a real token is provided, validate JWT format",
                  "        const jwtPattern = /^[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]+$/;",
                  "        pm.expect(requestBody.token).to.match(jwtPattern);",
                  "    }",
                  "});",
                  "",
                  "pm.test('Successful invalidation returns success response', function() {",
                  "    if (pm.response.code === 200) {",
                  "        if (jsonData.success !== undefined) {",
                  "            pm.expect(jsonData.success).to.be.true;",
                  "        }",
                  "    }",
                  "});",
                  "",
                  "pm.test('Invalid input returns appropriate error', function() {",
                  "    if (pm.response.code === 400) {",
                  "        pm.expect(jsonData.error || jsonData.message).to.exist;",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "5a1f86da-25f2-43be-b333-6fdc4db8dab3",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{accessToken}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"token\": \"jwt_token_to_invalidate\",\n  \"tokenType\": \"access\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/api/invalidate-token",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                "api",
                "invalidate-token"
              ]
            },
            "description": "Manually invalidate a specific token. Token type must be 'access' or 'refresh'."
          },
          "response": []
        },
        {
          "name": "Check Token Blacklist Status",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK or 404 for not found', function() {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 500ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(500);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains blacklisted status or error', function() {",
                  "    const hasStatus = jsonData.hasOwnProperty('blacklisted') || jsonData.hasOwnProperty('isBlacklisted') || jsonData.hasOwnProperty('status');",
                  "    const hasError = jsonData.hasOwnProperty('error') || jsonData.hasOwnProperty('message');",
                  "    pm.expect(hasStatus || hasError).to.be.true;",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Blacklisted field is boolean (if present)', function() {",
                  "    if (jsonData.blacklisted !== undefined) {",
                  "        pm.expect(jsonData.blacklisted).to.be.a('boolean');",
                  "    }",
                  "    if (jsonData.isBlacklisted !== undefined) {",
                  "        pm.expect(jsonData.isBlacklisted).to.be.a('boolean');",
                  "    }",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Response indicates token blacklist status', function() {",
                  "    if (pm.response.code === 200) {",
                  "        const isBlacklisted = jsonData.blacklisted || jsonData.isBlacklisted;",
                  "        pm.expect(typeof isBlacklisted).to.equal('boolean');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Blacklist timestamp is valid (if present)', function() {",
                  "    if (jsonData.blacklistedAt) {",
                  "        pm.expect(new Date(jsonData.blacklistedAt).toString()).to.not.equal('Invalid Date');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Token expiry is valid (if present)', function() {",
                  "    if (jsonData.expiresAt) {",
                  "        pm.expect(new Date(jsonData.expiresAt).toString()).to.not.equal('Invalid Date');",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "61ab7d59-a768-4671-b903-9f2a40cb1af9",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/api/check-token/:token",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                "api",
                "check-token",
                ":token"
              ],
              "variable": [
                {
                  "key": "token"
                }
              ]
            },
            "description": "Check if a token is blacklisted. Used for service-to-service communication."
          },
          "response": []
        },
        {
          "name": "Get Active Sessions",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK', function() {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('Request requires authentication (not 401 when token provided)', function() {",
                  "    pm.response.to.not.have.status(401);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 1000ms)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(1000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains sessions array', function() {",
                  "    const hasSessions = jsonData.hasOwnProperty('sessions') || Array.isArray(jsonData);",
                  "    pm.expect(hasSessions).to.be.true;",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Sessions is an array', function() {",
                  "    const sessions = jsonData.sessions || jsonData;",
                  "    pm.expect(sessions).to.be.an('array');",
                  "});",
                  "",
                  "// Business Logic Tests - Validate session objects",
                  "pm.test('Each session has required fields', function() {",
                  "    const sessions = jsonData.sessions || jsonData;",
                  "    sessions.forEach(function(session, index) {",
                  "        pm.expect(session).to.be.an('object', 'Session ' + index + ' should be an object');",
                  "    });",
                  "});",
                  "",
                  "pm.test('Session IDs are valid (if present)', function() {",
                  "    const sessions = jsonData.sessions || jsonData;",
                  "    sessions.forEach(function(session) {",
                  "        if (session.id || session.sessionId) {",
                  "            const id = session.id || session.sessionId;",
                  "            pm.expect(id).to.be.a('string');",
                  "        }",
                  "    });",
                  "});",
                  "",
                  "pm.test('Session timestamps are valid (if present)', function() {",
                  "    const sessions = jsonData.sessions || jsonData;",
                  "    sessions.forEach(function(session) {",
                  "        if (session.createdAt) {",
                  "            pm.expect(new Date(session.createdAt).toString()).to.not.equal('Invalid Date');",
                  "        }",
                  "        if (session.lastActivity) {",
                  "            pm.expect(new Date(session.lastActivity).toString()).to.not.equal('Invalid Date');",
                  "        }",
                  "    });",
                  "});",
                  "",
                  "pm.test('Session device info is valid (if present)', function() {",
                  "    const sessions = jsonData.sessions || jsonData;",
                  "    sessions.forEach(function(session) {",
                  "        if (session.device) {",
                  "            pm.expect(session.device).to.be.a('string');",
                  "        }",
                  "        if (session.userAgent) {",
                  "            pm.expect(session.userAgent).to.be.a('string');",
                  "        }",
                  "        if (session.ipAddress) {",
                  "            pm.expect(session.ipAddress).to.be.a('string');",
                  "        }",
                  "    });",
                  "});",
                  "",
                  "pm.test('Current session is marked (if applicable)', function() {",
                  "    const sessions = jsonData.sessions || jsonData;",
                  "    // At least one session should exist if user is authenticated",
                  "    if (sessions.length > 0) {",
                  "        const hasCurrentMarker = sessions.some(s => s.isCurrent === true || s.current === true);",
                  "        // This is optional - some APIs don't mark current session",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "1ba8640c-61db-4858-919d-3910ea281636",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{accessToken}}"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/api/sessions",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                "api",
                "sessions"
              ]
            },
            "description": "Get all active sessions for the current user"
          },
          "response": []
        },
        {
          "name": "Cleanup Expired Tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// Status Code Tests",
                  "pm.test('Status code is 200 OK or 202 Accepted', function() {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 202]);",
                  "});",
                  "",
                  "// Response Time Tests",
                  "pm.test('Response time is acceptable (under 5000ms for cleanup operation)', function() {",
                  "    pm.expect(pm.response.responseTime).to.be.below(5000);",
                  "});",
                  "",
                  "// Header Tests",
                  "pm.test('Content-Type header is present', function() {",
                  "    pm.response.to.have.header('Content-Type');",
                  "});",
                  "",
                  "pm.test('Content-Type is application/json', function() {",
                  "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                  "});",
                  "",
                  "// Schema Validation",
                  "pm.test('Response has valid JSON body', function() {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "",
                  "// Required Fields Tests",
                  "pm.test('Response contains success indicator or cleanup stats', function() {",
                  "    const hasIndicator = jsonData.hasOwnProperty('success') || jsonData.hasOwnProperty('message') || jsonData.hasOwnProperty('cleaned') || jsonData.hasOwnProperty('deletedCount');",
                  "    pm.expect(hasIndicator).to.be.true;",
                  "});",
                  "",
                  "// Data Type Tests",
                  "pm.test('Success field is boolean (if present)', function() {",
                  "    if (jsonData.success !== undefined) {",
                  "        pm.expect(jsonData.success).to.be.a('boolean');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Cleaned/deleted count is number (if present)', function() {",
                  "    if (jsonData.cleaned !== undefined) {",
                  "        pm.expect(jsonData.cleaned).to.be.a('number');",
                  "        pm.expect(jsonData.cleaned).to.be.at.least(0);",
                  "    }",
                  "    if (jsonData.deletedCount !== undefined) {",
                  "        pm.expect(jsonData.deletedCount).to.be.a('number');",
                  "        pm.expect(jsonData.deletedCount).to.be.at.least(0);",
                  "    }",
                  "});",
                  "",
                  "// Business Logic Tests",
                  "pm.test('Cleanup operation completed successfully', function() {",
                  "    if (jsonData.success !== undefined) {",
                  "        pm.expect(jsonData.success).to.be.true;",
                  "    } else {",
                  "        pm.expect(pm.response.code).to.be.oneOf([200, 202]);",
                  "    }",
                  "});",
                  "",
                  "pm.test('Cleanup timestamp is valid (if present)', function() {",
                  "    if (jsonData.cleanedAt || jsonData.timestamp) {",
                  "        const timestamp = jsonData.cleanedAt || jsonData.timestamp;",
                  "        pm.expect(new Date(timestamp).toString()).to.not.equal('Invalid Date');",
                  "    }",
                  "});",
                  "",
                  "pm.test('Next scheduled cleanup is valid (if present)', function() {",
                  "    if (jsonData.nextCleanup) {",
                  "        pm.expect(new Date(jsonData.nextCleanup).toString()).to.not.equal('Invalid Date');",
                  "    }",
                  "});"
                ]
              }
            }
          ],
          "id": "dcf9ce6d-8546-4bc7-a170-1be0cbe30167",
          "request": {
            "method": "POST",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}:{{logoutServicePort}}/api/cleanup-tokens",
              "host": [
                "{{baseUrl}}"
              ],
              "port": "{{logoutServicePort}}",
              "path": [
                "api",
                "cleanup-tokens"
              ]
            },
            "description": "Clean up expired blacklisted tokens. Maintenance endpoint for admin/service use."
          },
          "response": []
        }
      ],
      "id": "066b8a40-8c6b-4cfd-b762-8e5a413eb7bd",
      "description": "Manages token invalidation and session termination (Port 3002)"
    }
  ],
  "variable": [
    {
      "id": "9c3cd1a6-9263-4b41-bd85-90f4478292ba",
      "key": "baseUrl",
      "value": "http://localhost",
      "type": "string",
      "description": {
        "content": "Base URL for the API. Use 'Local Mock Server' environment for mock, 'Real Services' environment for actual services.",
        "type": "text/plain"
      }
    },
    {
      "id": "76177ccf-e734-48e1-adf0-017adf1955f3",
      "key": "loginServicePort",
      "value": "4500",
      "type": "string",
      "description": {
        "content": "Port for Login Service. Default set to mock server (4500). Use environments to switch between mock and real services.",
        "type": "text/plain"
      }
    },
    {
      "id": "9754cffb-ab1b-443b-9932-13f3983968ae",
      "key": "logoutServicePort",
      "value": "4500",
      "type": "string",
      "description": {
        "content": "Port for Logout Service. Default set to mock server (4500). Use environments to switch between mock and real services.",
        "type": "text/plain"
      }
    },
    {
      "id": "dc9597f9-18d0-4de8-b130-81abaa0d0c96",
      "key": "accessToken",
      "value": "",
      "type": "string"
    },
    {
      "id": "b894d2cd-e7f6-4219-9a2e-962299b525f9",
      "key": "refreshToken",
      "value": "",
      "type": "string"
    },
    {
      "id": "de125339-b736-4ce2-8da4-41b4f02a67fe",
      "key": "userId",
      "value": ""
    },
    {
      "id": "db6d1684-f9b8-4804-95ac-66ae9a4784be",
      "key": "randomEmail",
      "value": ""
    },
    {
      "id": "a2cf0693-6f91-4bdd-9021-e6d135fa9290",
      "key": "randomPassword",
      "value": ""
    },
    {
      "id": "c24697d6-cbe9-4e1c-895b-9ae486d9c1f9",
      "key": "registeredEmail",
      "value": ""
    },
    {
      "id": "e96452bc-87bc-4fcb-8787-760ad6d03082",
      "key": "userEmail",
      "value": ""
    }
  ]
}